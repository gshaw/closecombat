#include	<stdio.h>
#include	<stdlib.h>
#include	<windows.h>
#include	"ccElement.h"
#include	"ccLos.h"
#include	"ccMap.h"

// number of good element to element line of sight
// for a good titel to tile LOS
#define		GOODLINEBYTILE	4
// number of good tile to tile line of sight
// for a good metatile to metatile line of sight
#define		GOODTILEBYMETA	2

int		CClos_TextOutput ;

static char	CCLOS_VERSIONTEXT[] = "generated by    CClos v0.99b" ;

static PELEMENTDATA		eldata ; // elements datas
static int				elnum ;
static MAPXFERDATA		mapdata ; // map datas
static LINEOFSIGHTDATA	losdata ; // los datas

static int		*pre_elev ; // precalculated tile elevation
static int		*pre_height ; // precalculated tile elements height

//
//	fjumpline :
//		jump to the next line
//		return the first char of the line or EOF
//			   or '#' (equal to EOF in CC2 files)

static int fjumpline ( FILE *file )
{
	int	first_char,cur_char ;

	first_char = cur_char = fgetc ( file ) ;

	while ( cur_char != EOF && (cur_char > 13 || cur_char < 10) ) cur_char = fgetc ( file ) ;
	while ( cur_char != EOF && (cur_char <= 13 && cur_char >= 10) ) cur_char = fgetc ( file ) ;

	if ( cur_char != EOF )
	{
		fseek ( file , -1 , SEEK_CUR ) ;
		return first_char ;
	}
	else
	{
		if ( first_char == '#' )
				return first_char ;
		else	return EOF ;
	}
}

// fgetstring :
//		retrive a string terminated by a tab ('\t')
//		return 0 or EOF

static int fgetstring ( FILE *file, char *string )
{
	int cur_char ;
	int i ;

	cur_char = fgetc ( file ) ;
	i = 0 ;
	string[i] = 0 ;

	while ( cur_char != '\t' && cur_char != EOF )
		string[i++] = cur_char =  fgetc ( file ) ;

	string[i-1] = 0 ;

	if ( cur_char == EOF )
		 return EOF ;
	else return 0 ;
}

// ReadElement
//	element : path/name of the element file
//	load the element file in eldata

static int ReadElement ( char* element )
{
	long	dummy, count ;
	FILE	*elfile ;

	elfile = fopen ( element , "rb" ) ;

	if ( elfile == NULL )
		return -5 ;

	// found number of elements

		// found start ('&')
		dummy = fjumpline ( elfile ) ;
		while ( dummy != EOF && dummy != '&' )
				dummy =  fjumpline ( elfile ) ;

		if ( dummy == EOF )
		{
			fclose ( elfile ) ;
			return -2 ;
		}

		// count, ended by '#'
		dummy = fjumpline ( elfile ) ;
		elnum = 0 ;
		while ( dummy != EOF && dummy != '#' )
		{
			dummy = fjumpline ( elfile ) ;
			elnum++ ;
		}

		if ( dummy == EOF || elnum == 0 )
		{
			fclose ( elfile ) ;
			return -2 ;
		}

	// read file

	#ifdef _CONSOLE
		if (CClos_TextOutput)
			printf ( "Read elements file : %d elements\n" , elnum ) ;
	#endif

	eldata = malloc ( sizeof(ELEMENTDATA)*elnum ) ;

	if ( eldata == NULL )
	{
		fclose ( elfile ) ;
		return -3 ;
	}

		// found start ('&')

		fseek ( elfile , 0L , SEEK_SET ) ;
		dummy = fjumpline ( elfile ) ;

		while ( dummy != '&' && dummy != EOF )
			dummy = fjumpline ( elfile) ;

		// fill datas

		for ( count = 0 ; count < elnum ; count++ )
		{
			// read name

			fgetstring ( elfile , eldata[count].szName ) ;

			// read all the rest
			dummy = fscanf ( elfile , "%d \
									   %d %d %d %d %d %d %d %d %d %d \
									   %d %d %d %d %d %d %d %d %d %d \
									   %d %d %d %d %d %d %d %d %d %d \
									   %d %d %d %d %d %d %d %d %d %d",
									   &eldata[count].dwIndex,
									   &eldata[count].dwHeight,
									   &eldata[count].dwCover_Prone,
									   &eldata[count].dwCover_Low,
									   &eldata[count].dwCover_Medium,
									   &eldata[count].dwCover_High,
									   &eldata[count].dwProtection_Prone,
									   &eldata[count].dwProtection_Low,
									   &eldata[count].dwProtection_Medium,
									   &eldata[count].dwProtection_High,
									   &eldata[count].dwHindrance_Prone,
									   &eldata[count].dwHindrance_Low,
									   &eldata[count].dwHindrance_Medium,
									   &eldata[count].dwHindrance_High,
									   &eldata[count].bBlockHeight,
									   &eldata[count].bBlockAll,
									   &eldata[count].dwTopProtection,
									   &eldata[count].dwInElementProtectionFlag,
									   &eldata[count].dwHEEffect,
									   &eldata[count].dwSoldierMoveRate_Prone,
									   &eldata[count].dwSoldierMoveRate_Crouch,
									   &eldata[count].dwSoldierMoveRate_Standing,
									   &eldata[count].dwVehicleMoveRate_Truck,
									   &eldata[count].dwVehicleMoveRate_ArmoredCar,
									   &eldata[count].dwVehicleMoveRate_Halftrack,
									   &eldata[count].dwVehicleMoveRate_Tracked,
									   &eldata[count].dwVehicleMoveRate_Pushed,
									   &eldata[count].dwBogChance,
									   &eldata[count].bFlag_Wall,
									   &eldata[count].bFlag_Building,
									   &eldata[count].bFlag_Sunken,
									   &eldata[count].bFlag_Crushable,
									   &eldata[count].bFlag_Covered,
									   &eldata[count].bFlag_Bridge,
									   &eldata[count].bFlag_Flammable,
									   &eldata[count].dwBridgeDirection,
									   &eldata[count].dwExplode,
									   &eldata[count].dwTileType,
									   &eldata[count].dwLevel,
									   &eldata[count].dwRubbleTo,
									   &eldata[count].dwCrushTo ) ;

			if ( dummy != 41 )
			{
				printf ( "only %d parts on element %d : %s\n" , (dummy+1) , count, eldata[count].szName ) ;
				free ( eldata ) ;
				fclose ( elfile ) ;
				return -2 ;
			}
		}

	fclose ( elfile ) ;

	return 0 ;
}

// ReadMap
//	mapfile : path\name of the file
//	read a map in mapdata
static int ReadMap ( char* mapfile )
{
	int		end ;
	long	dummy2, dummy, count ;
	FILE	*file ;
	PMAPINDEXDATA index ;

	file = fopen ( mapfile , "rb" ) ;

	if ( file == NULL )
		return -4 ;

	// don't use version ID
	dummy = fjumpline ( file ) ;

	if ( dummy == EOF )
	{
		fclose (file) ;
		return -1 ;
	}

	// get X coord
	dummy = fscanf ( file , "%d" , &mapdata.dwX ) ;

	if ( dummy != 1 )
	{
		fclose (file) ;
		return -1 ;
	}

	dummy = fjumpline ( file ) ;

	if ( dummy == EOF )
	{
		fclose (file) ;
		return -1 ;
	}

	// get Y coord
	dummy = fscanf ( file , "%d" , &mapdata.dwY ) ;

	if ( dummy != 1 )
	{
		fclose (file) ;
		return -1 ;
	}

	#ifdef _CONSOLE
	if (CClos_TextOutput)
		printf ( "Load %d x %d map file\n" , mapdata.dwX , mapdata.dwY ) ;
	#endif

	dummy = fjumpline ( file ) ;

	if ( dummy == EOF )
	{
		fclose (file) ;
		return -1 ;
	}

	// jump to data start ('&')

	dummy = fjumpline ( file ) ;

	while ( dummy != EOF && dummy != '&' )
		dummy = fjumpline ( file ) ;

	if ( dummy == EOF )
	{
		fclose (file);
		return -1 ;
	}

	end = mapdata.dwX * mapdata.dwY ;

	// get memory

	mapdata.Index = malloc ( end * sizeof(MAPINDEXDATA) ) ;

	if ( mapdata.Index == NULL )
	{
		fclose (file) ;
		return -3;
	}

	// read data


	for ( count = 0 ; count < end ; count++ )
	{
		index = &(mapdata.Index[count]) ;

		dummy2 = fscanf( file , "%d \
						%d %d %d %d \
						%d %d %d %d \
						%d %d %d %d \
						%d %d %d %d \
						%d",
						&dummy,
						&index->dwElement[0],
						&index->dwElement[1],
						&index->dwElement[2],
						&index->dwElement[3],
						&index->dwElement[4],
						&index->dwElement[5],
						&index->dwElement[6],
						&index->dwElement[7],
						&index->dwElement[8],
						&index->dwElement[9],
						&index->dwElement[10],
						&index->dwElement[11],
						&index->dwElement[12],
						&index->dwElement[13],
						&index->dwElement[14],
						&index->dwElement[15],
						&index->dwElevation );

		if ( dummy2 != 18 )
		{
			free (mapdata.Index) ;
			fclose ( file ) ;
			return -4 ;
		}

	}

	fclose (file) ;
	return 0 ;
}

// CheckElementLine : Check line between two elements
//	same parameter than CheckLos
//  Brensenham algorythm

static int CheckElementLine ( int x_ori, int y_ori,
							  int x_dest, int y_dest,
							  int ori_elev, int dest_elev )
{
	float	elev, elev_mod ;
	int		x,y,dx,dy,s1,s2,interchange,e, i ;

	x = x_ori ;
	y = y_ori ;
	dx = abs(x_dest-x_ori) ;
	dy = abs(y_dest-y_ori) ;

	if ( (x_dest-x_ori) > 0 )
			s1 = 1 ;
	else	if ( dx == 0 )
					s1 = 0  ;
			else	s1 = -1 ;

	if ( (y_dest-y_ori) > 0 )
			s2 = 1 ;
	else	if ( dy == 0 )
					s2 = 0  ;
			else	s2 = -1 ;

	elev = (float)ori_elev ;

	if ( dy > dx )
	{
		interchange = dx ;
		dx = dy ;
		dy = interchange ;
		interchange = 1 ;
	}
	else
		interchange = 0 ;

	e = 2*dy - dx ;
	elev_mod = ((float)(dest_elev-ori_elev))/dx ;

	for ( i = 1 ; i < dx ; i++ )
	{
		while ( e >= 0 )
		{
			if ( interchange )
					x = x + s1 ;
			else	y = y + s2 ;

			e -= 2*dx ;
		}

		if ( interchange )
				y = y + s2 ;
		else	x = x + s1 ;

		e += 2*dy ;
		elev += elev_mod ;

		// Check point
		if ( pre_height[x+y*(mapdata.dwX*4)] > elev )
			return 0 ;
	}
	return 1 ;
}

//
// CheckLos : check if a line of sight is good or not
//	x_ori, y_ori : origin tile
//	x_dest, y_dest : destination tile
//	ori_elev : origin elevation
//	dest_elev : destination elevation
//	return 1 if ok, 0 if LOS broken

static int CheckLos ( int x_ori, int y_ori,
					  int x_dest, int y_dest,
					  int ori_elev, int dest_elev )
{
	int count ;
	int to, td ;
	int dx, dy ;

	int	*Tori_x ;
	int *Tori_y ;
	int Tdest_x[4] ;
	int Tdest_y[4] ;

	int TTori_x[4][4]  = { { 3 , 3 , 3 , 3 } , { 2 , 3 , 3 , 3 } , { 1 , 2 , 3 , 3 } , { 0 , 1 , 2 , 3 } } ;
	int TTori_y[4][4]  = { { 0 , 1 , 2 , 3 } , { 0 , 0 , 1 , 2 } , { 0 , 0 , 0 , 1 } , { 0 , 0 , 0 , 0 } } ;

	if ( x_ori == x_dest && y_ori == y_dest )
		return 1 ;

	// select elements concerned

	dx = abs(x_dest-x_ori) ;
	dy = abs(y_dest-y_ori) ;

	if ( dx > 4*dy )
		count = 0 ;
	else
	if ( dy > 4*dx )
		count = 3 ;
	else
	if ( dx > dy )
		count = 1 ;
	else
		count = 2 ;

	Tori_x = TTori_x[count] ;
	Tori_y = TTori_y[count] ;

	if ( (x_dest - x_ori) < 0 )
	{
		Tori_x[0] = abs(Tori_x[0]-3)   ; Tori_x[1] = abs(Tori_x[1]-3) ;
		Tori_x[2] = abs(Tori_x[2]-3)   ; Tori_x[3] = abs(Tori_x[3]-3) ;
	}

	if ( (y_dest - y_ori) < 0 )
	{
		Tori_y[0] = abs(Tori_y[0]-3)   ; Tori_y[1] = abs(Tori_y[1]-3)   ;
		Tori_y[2] = abs(Tori_y[2]-3)   ; Tori_y[3] = abs(Tori_y[3]-3)   ;
	}

	Tdest_x[0] = abs(Tori_x[0]-3) ; Tdest_x[1] = abs(Tori_x[1]-3) ;
	Tdest_x[2] = abs(Tori_x[2]-3) ; Tdest_x[3] = abs(Tori_x[3]-3) ;

	Tdest_y[0] = abs(Tori_y[0]-3) ; Tdest_y[1] = abs(Tori_y[1]-3) ;
	Tdest_y[2] = abs(Tori_y[2]-3) ; Tdest_y[3] = abs(Tori_y[3]-3) ;

	for ( to = 0 ; to < 4 ; to++ )
	{
		Tori_x[to] += x_ori*4 ;
		Tori_y[to] += y_ori*4 ;
		Tdest_x[to] += x_dest*4 ;
		Tdest_y[to] += y_dest*4 ;
	}

	count = 0 ;

	for ( to = 0 ; to < 4 ; to++ )
		for ( td = 0 ; td < 4 ; td++ )
		{
			if ( CheckElementLine ( Tori_x[to]  , Tori_y[to],
									Tdest_x[td] , Tdest_y[td],
									ori_elev, dest_elev ) )
								count++ ;
			if ( count >= GOODLINEBYTILE )
				to = td = 4 ;
		}

	if (count >= GOODLINEBYTILE )
			return 1 ;
	else	return 0 ;
}

// MegaTileCalculate
//	x_ori,y_ori : megatile calculated
//	type : 1 - SxS
//		   2 - SxV
//		   3 - VxS
//		   4 - VxV

static void MegaTileCalculate ( int x_ori, int y_ori, int type )
{
	DWORD x_dest, y_dest ;
	int io , jo, id, jd ;
	int ori_inc, dest_inc ;
	BYTE	*result ;
	int		count ;
	BYTE	los_ok ;

	switch ( type )
	{
	case 1:
		ori_inc = dest_inc = 2 ;
		result = losdata.Tile[x_ori+y_ori*(losdata.X)].pSxS ;
		break ;
	case 2:
		ori_inc = 2 ; dest_inc = 4 ;
		result = losdata.Tile[x_ori+y_ori*(losdata.X)].pSxV ;
		break ;
	case 3:
		ori_inc = 4 ; dest_inc = 2 ;
		result = losdata.Tile[x_ori+y_ori*(losdata.X)].pVxS ;
		break ;
	default:
		ori_inc = dest_inc = 4 ;
		result = losdata.Tile[x_ori+y_ori*(losdata.X)].pVxV ;
	}

	los_ok = 0x80 ;

	// zero ( clean memory )
	for ( io = 0 ; io < losdata.BlockSize ; io++ )
			result[io] = 0 ;

	for ( x_dest = 0 ; x_dest < losdata.X ; x_dest++ )
		for ( y_dest = 0 ; y_dest < losdata.Y ; y_dest++ )
		{
			count = 0 ;
			for ( io = 0 ; io < 3 ; io++ )
				for ( jo = 0 ; jo < 3 ; jo++ )
					for ( id = 0 ; id < 3 ; id++ )
						for ( jd = 0 ; jd < 3 ; jd++ )
						{
							if ( CheckLos ( x_ori*3+io , y_ori*3+jo ,
											x_dest*3+id , y_dest*3+jd ,
											ori_inc + pre_elev[x_ori*3+io+(y_ori*3+jo)*mapdata.dwX],
											dest_inc + pre_elev[x_dest*3+id+(y_dest*3+jd)*mapdata.dwX] ) )
									count++ ;

							if ( count > GOODTILEBYMETA ) // if suffisant number of good sight, break
								io = jo = id = jd = 3 ;
						}

			if ( count > GOODTILEBYMETA )
				*result |= los_ok ;

			if ( los_ok == 0x01 )
			{
					los_ok = 0x80 ;
					result++ ;
			}
			else	los_ok >>= 1 ;
		}
}

// LOScalculate
//	mapfile : map name and path
//  losfile : los name and path
//	element : element file used (path and name)
//	return : 0 - all Ok
//			-1 - bad map file
//			-2 - bad element file
//			-3 - not enought memory
//			-4 - map file not found
//			-5 - element file not found
//			-6 - can't create los file (write protect)
//			-7 - disk full
//			-8 - bad element in map

int LOScalculate ( char* mapfile, char* losfile, char* element , int mode )
{
	DWORD i,j,k ;
	DWORD tilenum ;
	int status ;
	char *buffer ;
	FILE *los ;

	if ( (status=ReadElement ( element )) != 0 )
		return status ;

	#ifdef _CONSOLE
	if (CClos_TextOutput)
		printf ( "Element file succefully readed\n" ) ;
	#endif

	if ( (status=ReadMap ( mapfile )) != 0 )
	{
		free ( eldata ) ;
		return status ;
	}

	#ifdef _CONSOLE
	if (CClos_TextOutput)
		printf ("Map file succesully readed\n" ) ;
	#endif

	// intialize los struct

	losdata.X = mapdata.dwX / 3 ;
	losdata.Y = mapdata.dwY / 3 ;
	tilenum = (losdata.X * losdata.Y) ;
	losdata.BlockSize = tilenum /8 ;

	if ( tilenum % 8 )
		losdata.BlockSize++ ;

	buffer = malloc ((tilenum * losdata.BlockSize * 4) + sizeof(LOSTILEDATA)*tilenum) ;

	if ( buffer == NULL )
	{
		free ( mapdata.Index ) ;
		free ( eldata ) ;
		return -4 ;
	}

	losdata.Tile = (LOSTILEDATA *)buffer ;

	for ( i = 0 ; i < tilenum ; i++ )
	{
		losdata.Tile[i].pSxS = buffer + sizeof(LOSTILEDATA)*tilenum + losdata.BlockSize * 4 * i ;
		losdata.Tile[i].pSxV = losdata.Tile[i].pSxS + losdata.BlockSize ;
		losdata.Tile[i].pVxS = losdata.Tile[i].pSxV + losdata.BlockSize ;
		losdata.Tile[i].pVxV = losdata.Tile[i].pVxS + losdata.BlockSize ;
	}

	pre_elev = malloc (tilenum * sizeof(int) * 9) ;

	if ( pre_elev == NULL )
	{
		free ( buffer ) ;
		free ( mapdata.Index ) ;
		free ( eldata ) ;
		return -4 ;
	}

	pre_height = malloc ( tilenum * sizeof(int) * 9 * 16 ) ;

	if ( pre_height == NULL )
	{
		free ( pre_elev ) ;
		free ( buffer ) ;
		free ( mapdata.Index ) ;
		free ( eldata ) ;
		return -4 ;
	}

	// precalc tile elevation

	#ifdef _CONSOLE
	if (CClos_TextOutput)
		printf ( "Start Precalc\n" ) ;
	#endif

	for ( i = 0 ; i < mapdata.dwX*mapdata.dwY ; i++ )
	{
			pre_elev[i] = mapdata.Index[i].dwElevation ;

			// search max level in the 16 elements

			k = 0 ;
			for ( j = 0 ; j < 16 ; j++ )
				if ( eldata[mapdata.Index[i].dwElement[j]].dwLevel > k )
					k = eldata[mapdata.Index[i].dwElement[j]].dwLevel ;

			pre_elev[i] += k * 10 ;
	}

	// precalc elements height

	for ( i = 0 ; i < mapdata.dwX*4 ; i++ )
		for ( j = 0 ; j < mapdata.dwY*4 ; j++ )
		{
			// verify map info
			if ( mapdata.Index[(i/4)+(j/4)*mapdata.dwX].dwElement[(i%4)+(j%4)*4] > elnum )
			{
				#ifdef _CONSOLE
				if (CClos_TextOutput)
				{
					printf ( "In tile %dx%d of map, element %d is %d.\n" ,
							(i/4) , (j/4) , (i%4)+(j%4)*4 , mapdata.Index[(i/4)+(j/4)*mapdata.dwX].dwElement[(i%4)+(j%4)*4] ) ;
					printf ( "max element index : %d\n" , elnum ) ;
				}
				#endif

				free ( pre_elev ) ;
				free ( buffer ) ;
				free ( mapdata.Index ) ;
				free ( eldata ) ;
				return -8 ;
			}

			pre_height[i+j*mapdata.dwX*4] =
					  mapdata.Index[(i/4)+(j/4)*mapdata.dwX].dwElevation
					  + eldata[mapdata.Index[(i/4)+(j/4)*mapdata.dwX].dwElement[(i%4)+(j%4)*4]].dwHeight
					  + eldata[mapdata.Index[(i/4)+(j/4)*mapdata.dwX].dwElement[(i%4)+(j%4)*4]].dwLevel * 10 ;
		}

	#ifdef _CONSOLE
	if (CClos_TextOutput)
		printf ( "Precalc done\n" ) ;
	#endif

	// 	calculate LOS

	for ( j = 0 ; j < losdata.Y ; j++ )
		for ( i = 0 ; i < losdata.X ; i++ )
		{
			#ifdef _CONSOLE
			if (CClos_TextOutput)
				printf ( "Calculate los : %3.1f %% completed\r" , ((i+j*losdata.X)*100.0) / (losdata.X*losdata.Y) ) ;
			#endif
			MegaTileCalculate ( i , j , 1 ) ;
			MegaTileCalculate ( i , j , 2 ) ;
			MegaTileCalculate ( i , j , 3 ) ;
			MegaTileCalculate ( i , j , 4 ) ;
		}

	#ifdef _CONSOLE
	if (CClos_TextOutput)
		printf ( "Calculate los : 100.0 %% completed\n" ) ;
	#endif

	// save LOS

	#ifdef _CONSOLE
	if (CClos_TextOutput)
		printf ( "Saving...\n" ) ;
	#endif

	los = fopen ( losfile , "wb" ) ;

	if ( los == NULL )
	{
		free ( pre_elev ) ;
		free ( pre_height ) ;
		free ( buffer ) ;
		free ( mapdata.Index ) ;
		free ( eldata ) ;
		return -6 ;
	}

	for ( i = 0 ; i < losdata.X*losdata.Y ; i++ )
	{
		j = fwrite ( losdata.Tile[i].pSxS , sizeof(BYTE) , losdata.BlockSize , los ) ;

		if ( j < losdata.BlockSize )
		{
			fclose ( los ) ;
			free ( pre_elev ) ;
			free ( pre_height ) ;
			free ( buffer ) ;
			free ( mapdata.Index ) ;
			free ( eldata ) ;
			return -7 ;
		}

		j = fwrite ( losdata.Tile[i].pSxV , sizeof(BYTE) , losdata.BlockSize , los ) ;

		if ( j < losdata.BlockSize )
		{
			fclose ( los ) ;
			free ( pre_elev ) ;
			free ( pre_height ) ;
			free ( buffer ) ;
			free ( mapdata.Index ) ;
			free ( eldata ) ;
			return -7 ;
		}

		j = fwrite ( losdata.Tile[i].pVxS , sizeof(BYTE) , losdata.BlockSize , los ) ;

		if ( j < losdata.BlockSize )
		{
			fclose ( los ) ;
			free ( pre_elev ) ;
			free ( pre_height ) ;
			free ( buffer ) ;
			free ( mapdata.Index ) ;
			free ( eldata ) ;
			return -7 ;
		}

		j = fwrite ( losdata.Tile[i].pSxS , sizeof(BYTE) , losdata.BlockSize , los ) ;

		if ( j < losdata.BlockSize )
		{
			fclose ( los ) ;
			free ( pre_elev ) ;
			free ( pre_height ) ;
			free ( buffer ) ;
			free ( mapdata.Index ) ;
			free ( eldata ) ;
			return -7 ;
		}

	}

	fprintf ( los , CCLOS_VERSIONTEXT ) ;

	fclose ( los ) ;
	free ( pre_elev ) ;
	free ( pre_height ) ;
	free ( buffer ) ;
	free ( mapdata.Index ) ;
	free ( eldata ) ;

	return 0 ;
}

